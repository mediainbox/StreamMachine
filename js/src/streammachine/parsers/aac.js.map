{
  "version": 3,
  "file": "aac.js",
  "sourceRoot": "../../../../src/streammachine/parsers/",
  "sources": [
    "aac.coffee"
  ],
  "names": [],
  "mappings": "AAAA,IAAA,GAAA,EAAA,cAAA,EAAA,mBAAA,EAAA,WAAA,EAAA,kBAAA,EAAA,QAAA,EAAA,oBAAA,EAAA,kBAAA,EAAA,MAAA,EAAA;;AAAA,MAAA,GAAS,OAAA,CAAQ,SAAR;;AACT,MAAA,GAAS,OAAA,CAAQ,QAAR;;AAET,QAAA,GAAW,CACP,MADO,EAEP,UAFO,EAGP,QAHO,EAIP,SAJO,EAKP,SALO,EAMP,KANO,EAOP,cAPO,EAQP,QARO;;AAWX,kBAAA,GAAqB,CACjB,KADiB,EACV,KADU,EACH,KADG,EACI,KADJ,EACW,KADX,EACkB,KADlB,EACyB,KADzB,EACgC,KADhC,EACuC,KADvC,EAC8C,KAD9C,EACqD,KADrD,EAC4D,IAD5D,EACkE,IADlE;;AAIrB,cAAA,GAAiB,CACb,CADa,EACX,CADW,EACT,CADS,EACP,CADO,EACL,CADK,EACH,CADG,EACD,CADC,EACC,CADD;;AAIjB,kBAAA,GAAsB;;AACtB,mBAAA,GAAsB;;AAEtB,WAAA,GAA0B,IAAI,MAAM,CAAC,UAAX,CAAsB,kBAAtB;;AAC1B,oBAAA,GAA0B,IAAI,MAAM,CAAC,UAAX,CAAsB,mBAAA,GAAsB,kBAA5C;;AAE1B,MAAM,CAAC,OAAP,GAAuB;;;EAAN,MAAA,IAAA,QAAkB,OAAA,CAAQ,QAAR,CAAiB,CAAC,SAApC;IAIb,WAAa,CAAA,CAAA;AACjB,UAAA;WAAQ,CAAA,EAAR;;MAGQ,IAAC,CAAA,OAAD,GAAW,IAAA,CAAI,CAAC,OAAA,CAAQ,QAAR,CAAiB,CAAC,YAAnB,CAAJ,CAAA,CAAA;MAEX,IAAC,CAAA,SAAD,GAAa,MALrB;;MAQQ,IAAC,CAAA,SAAD,GAAc,CAAC;MACf,IAAC,CAAA,SAAD,GAAc;MACd,IAAC,CAAA,KAAD,GAAc;MACd,IAAC,CAAA,OAAD,GAAc;MACd,IAAC,CAAA,KAAD,GAAc;MACd,IAAC,CAAA,MAAD,GAAc;MAEd,IAAC,CAAA,WAAD,GAAkB;MAClB,IAAC,CAAA,cAAD,GAAkB;MAElB,IAAC,CAAA,KAAD,GAAsB;MACtB,IAAC,CAAA,aAAD,GAAsB;MACtB,IAAC,CAAA,eAAD,GAAsB;MACtB,IAAC,CAAA,QAAD,GAAsB;MACtB,IAAC,CAAA,QAAD,GAAsB;MAEtB,IAAC,CAAA,IAAD,CAAM,QAAN,EAAgB,CAAA,CAAA,GAAA;eACZ,IAAC,CAAA,SAAD,GAAa,UAAA,CAAW,CAAA,CAAA,GAAA;iBACpB,IAAC,CAAA,IAAD,CAAM,KAAN;QADoB,CAAX,EAEX,GAFW;MADD,CAAhB;MAKA,gBAAA,GAAmB,CAAA,GAAC,IAAD,CAAA,GAAA;QACf,IAAC,CAAA,IAAD,CAAM,GAAA,IAAN;QAEA,IAAG,IAAC,CAAA,SAAJ;UACI,YAAA,CAAa,IAAC,CAAA,SAAd;iBACA,IAAC,CAAA,SAAD,GAAa,UAAA,CAAW,CAAA,CAAA,GAAA;mBACpB,IAAC,CAAA,IAAD,CAAM,KAAN;UADoB,CAAX,EAEX,GAFW,EAFjB;;MAHe;MASnB,MAAM,CAAC,KAAP,CAAa,IAAC,CAAA,OAAd,EAAuB,CAAC,CAAD,EAAG,EAAH,CAAA,GAAA;AAC/B,YAAA,CAAA,EAAA,GAAA,EAAA,CAAA,EAAA,KAAA,EAAA,CAAA,EAAA,GAAA;;QAEY,IAAG,CAAA,KAAK,MAAR;;AAEI,iBAAO,WAFX;SAFZ;;QAQY,IAAG,IAAC,CAAA,aAAJ;;;UAII,IAAC,CAAA,KAAK,CAAC,YAAP,GAAsB,CAAC,CAAC,CAAD;UACvB,IAAC,CAAA,KAAK,CAAC,KAAP,GAAe,CAAC,CAAC,CAAD,EAJhC;;UAOgB,IAAC,CAAA,KAAK,CAAC,MAAP,GAAiB,CAAC,CAAC,CAAC,CAAD,CAAD,GAAO,IAAR,CAAA,GAAgB,CAAC,CAAE,CAAC,CAAC,CAAD,CAAD,GAAO,IAAT,CAAA,IAAmB,CAApB,CAAhB,GAAyC,CAAC,CAAE,CAAC,CAAC,CAAD,CAAD,GAAO,IAAT,CAAA,IAAmB,EAApB,CAAzC,GAAmE,CAAC,CAAE,CAAC,CAAC,CAAD,CAAD,GAAO,IAAT,CAAA,IAAmB,EAApB;UAEpF,IAAC,CAAA,aAAD,GAAiB;UACjB,IAAC,CAAA,eAAD,GAAmB;UACnB,IAAC,CAAA,QAAD,GAAY;AAEZ,iBAAO,IAAI,MAAM,CAAC,UAAX,CAAsB,IAAC,CAAA,KAAK,CAAC,MAA7B,EAdX;;QAgBA,IAAG,IAAC,CAAA,eAAJ;;UAEI,CAAA,GAAI,MAAM,CAAC,MAAP,CAAc,CAAC,IAAC,CAAA,QAAF,EAAY,IAAC,CAAA,QAAb,EAAuB,CAAvB,CAAd;UACJ,gBAAA,CAAiB,OAAjB,EAA0B,CAA1B;UAEA,IAAC,CAAA,eAAD,GAAmB;AAEnB,iBAAO,WAPX;SAxBZ;;QAmCY,IAAG,IAAC,CAAA,SAAD,KAAc,CAAC,CAAf,IAAoB,IAAC,CAAA,WAAxB;;;UAII,GAAA,GAAM,CAAC,CAAC,QAAF,CAAW,OAAX,EAAoB,CAApB,EAAuB,CAAvB;UAEN,IAAG,GAAA,KAAO,KAAV;;YAEI,gBAAA,CAAiB,OAAjB,EAA0B,YAA1B;YACA,IAAC,CAAA,aAAD,GAAiB;YACjB,IAAC,CAAA,KAAD,GAAS;cAAA,YAAA,EAAa,CAAC,CAAC,CAAD;YAAd;YACT,IAAC,CAAA,QAAD,GAAY;AAEZ,mBAAO,qBAPX;WAAA,MAAA;AASI;cACI,CAAA,GAAI,IAAC,CAAA,UAAD,CAAY,CAAZ,EADR;aAEA,aAAA;cAAM,UAC1B;;cACwB,OAAO,CAAC,GAAR,CAAY,oBAAZ,EAAkC,CAAlC,EAAqC,IAAC,CAAA,WAAtC;cACA,IAAC,CAAA,WAAD,GAAe;AACf,qBAAO,WAJX;;YAMA,IAAC,CAAA,WAAD,GAAkB;YAClB,IAAC,CAAA,cAAD,GAAkB;YAClB,gBAAA,CAAiB,QAAjB,EAA2B,CAA3B;YACA,IAAC,CAAA,SAAD,GAAa,IAAC,CAAA,WAAW,CAAC;YAE1B,IAAG,IAAC,CAAA,SAAD,KAAc,CAAjB;;cAEI,OAAO,CAAC,GAAR,CAAY,wBAAZ,EAAsC,CAAtC;AACA,qBAAO,WAHX;aAAA,MAAA;AAKI,qBAAO,IAAI,MAAM,CAAC,UAAX,CAAsB,IAAC,CAAA,SAAD,GAAa,CAAC,CAAC,MAArC,EALX;aAtBJ;WANJ;SAnCZ;;QAwEY,IAAG,IAAC,CAAA,KAAD,IAAW,IAAC,CAAA,OAAf;UACI,GAAA,GAAM,MAAM,CAAC,KAAP,CAAa,CAAA,GAAE,CAAC,CAAC,MAAjB;UACN,GAAG,CAAC,CAAD,CAAH,GAAS;UACT,GAAG,CAAC,CAAD,CAAH,GAAS,IAAC,CAAA;UACV,CAAC,CAAC,IAAF,CAAO,GAAP,EAAW,CAAX;AAEA;YACI,CAAA,GAAI,IAAC,CAAA,UAAD,CAAY,GAAZ,EADR;WAEA,aAAA;YAAM,UACtB;;YACoB,OAAO,CAAC,GAAR,CAAY,kCAAZ,EAAgD,GAAhD;YACA,IAAC,CAAA,KAAD,GAAS;YACT,IAAC,CAAA,OAAD,GAAW;AACX,mBAAO,WALX;WAPhB;;UAegB,IAAC,CAAA,KAAD,GAAS;UACT,IAAC,CAAA,OAAD,GAAW;UACX,IAAC,CAAA,SAAD,GAAa;UAEb,IAAC,CAAA,WAAD,GAAkB;UAClB,IAAC,CAAA,cAAD,GAAkB;UAClB,gBAAA,CAAiB,QAAjB,EAA2B,CAA3B;UACA,IAAC,CAAA,SAAD,GAAa,IAAC,CAAA,WAAW,CAAC;UAE1B,IAAC,CAAA,KAAD,GAAS,CAAC,CAAC;UAEX,IAAG,IAAC,CAAA,SAAD,KAAc,CAAjB;;YAEI,OAAO,CAAC,GAAR,CAAY,wBAAZ,EAAsC,CAAtC;AAEA,mBAAO,WAJX;WAAA,MAAA;;AAOI,mBAAO,IAAI,MAAM,CAAC,UAAX,CAAsB,IAAC,CAAA,SAAD,GAAa,GAAG,CAAC,MAAvC,EAPX;WA3BJ;;QAoCA,IAAG,IAAC,CAAA,KAAJ;UACI,IAAG,CAAC,CAAC,CAAD,CAAD,IAAM,CAAN,KAAW,GAAd;YACI,IAAC,CAAA,OAAD,GAAW,CAAC,CAAC,CAAD,EAAhC;;;YAKoB,IAAG,CAAC,CAAC,CAAC,CAAD,CAAD,GAAO,CAAR,CAAA,KAAc,CAAjB;;;;;;AAOI,qBAAO,IAAI,MAAM,CAAC,UAAX,CAA0B,CAAC,CAAC,CAAC,CAAD,CAAD,GAAO,CAAR,CAAA,KAAc,CAAjB,GAAwB,CAAxB,GAA+B,CAAtD,EAPX;aAAA,MAAA;cASI,IAAC,CAAA,KAAD,GAAS,MATb;aANJ;WAAA,MAAA;YAkBI,IAAC,CAAA,KAAD,GAAS,MAlBb;WADJ;;QAqBA,IAAG,IAAC,CAAA,SAAD,KAAc,CAAC,CAAf,IAAoB,CAAC,IAAC,CAAA,KAAzB;UACI,IAAG,CAAC,CAAC,CAAD,CAAD,KAAQ,IAAX;;YAEI,IAAC,CAAA,KAAD,GAAS;AACT,mBAAO,WAHX;WAAA,MAIK,IAAG,CAAC,CAAC,CAAD,CAAD,KAAQ,IAAX;;YAED,IAAC,CAAA,MAAD,GAAU;AACV,mBAAO,WAHN;WAAA,MAKA,IAAG,IAAC,CAAA,MAAD,KAAW,CAAX,IAAgB,CAAC,CAAC,CAAD,CAAD,KAAQ,IAA3B;YACD,IAAC,CAAA,MAAD,GAAU;AACV,mBAAO,WAFN;WAAA,MAIA,IAAG,IAAC,CAAA,MAAD,KAAW,CAAX,IAAgB,CAAC,CAAC,CAAD,CAAD,KAAQ,IAA3B;YACD,IAAC,CAAA,MAAD,GAAU;AACV,mBAAO,WAFN;WAAA,MAIA,IAAG,IAAC,CAAA,MAAD,KAAW,CAAd;YACD,IAAC,CAAA,QAAD,GAAY,MAAM,CAAC,IAAP,CAAY,CAAC,IAAD,EAAM,IAAN,EAAW,IAAX,EAAgB,CAAC,CAAC,CAAD,CAAjB,CAAZ;YACZ,IAAC,CAAA,KAAD,GAAS;cAAA,YAAA,EAAa,CAAC,CAAC,CAAD;YAAd;YACT,IAAC,CAAA,aAAD,GAAiB;YACjB,IAAC,CAAA,MAAD,GAAU;AACV,mBAAO,qBALN;WAAA,MAAA;;AAQD,mBAAO,WARN;WAlBT;SAjIZ;;QA+JY,IAAG,IAAC,CAAA,cAAJ;UACI,KAAA,GAAQ,MAAM,CAAC,KAAP,CAAc,IAAC,CAAA,cAAc,CAAC,MAAhB,GAAyB,CAAC,CAAC,MAAzC;UACR,IAAC,CAAA,cAAc,CAAC,IAAhB,CAAqB,KAArB,EAA2B,CAA3B;UACA,CAAC,CAAC,IAAF,CAAO,KAAP,EAAa,IAAC,CAAA,cAAc,CAAC,MAA7B;UACA,gBAAA,CAAiB,OAAjB,EAA0B,KAA1B,EAAiC,IAAC,CAAA,WAAlC,EAJJ;;QAMA,IAAC,CAAA,SAAD,GAAa,CAAC,EArK1B;;AAwKY,eAAO,IAAI,MAAM,CAAC,UAAX,CAA0B,IAAC,CAAA,KAAJ,GAAe,CAAf,GAAsB,CAA7C;MAzKY,CAAvB;IAvCS,CAFjB;;;IAsNI,MAAQ,CAAC,KAAD,EAAO,QAAP,EAAgB,QAAhB,CAAA;MACJ,IAAC,CAAA,OAAO,CAAC,IAAT,CAAc,MAAd,EAAsB,KAAtB;8CACA;IAFI,CAtNZ;;;IA4NI,UAAY,CAAC,CAAD,CAAA;AAChB,UAAA;MAAQ,MAAM,CAAC,EAAP,CAAU,MAAM,CAAC,QAAP,CAAgB,CAAhB,CAAV;MACA,MAAM,CAAC,EAAP,CAAU,CAAC,CAAC,MAAF,IAAW,CAArB,EADR;;MAKQ,MAAM,CAAC,EAAP,CAAY,CAAC,CAAC,CAAD,CAAD,KAAQ,IAAR,IAAgB,CAAC,CAAC,CAAC,CAAD,CAAD,IAAQ,CAAT,CAAA,KAAe,GAA3C,EAAkD,gCAAlD,EALR;;MASQ,MAAA,GACI;QAAA,GAAA,EAAoB,CAAC,CAAC,CAAC,CAAC,CAAD,CAAD,GAAO,GAAR,CAArB;QACA,SAAA,EAAuB,CAAC,CAAC,CAAC,CAAD,CAAD,GAAO,GAAR,CAAH,GAAqB,OAArB,GAAkC,OADtD;QAEA,OAAA,EAAoB,CAAC,CAAC,CAAC,CAAD,CAAD,IAAQ,CAAT,CAAA,GAAc,CAFlC;QAGA,WAAA,EAAoB,kBAAkB,CAAE,CAAC,CAAC,CAAD,CAAD,IAAQ,CAAR,GAAY,GAAd,CAHtC;QAIA,cAAA,EAAoB,CAAC,CAAC,CAAC,CAAD,CAAD,GAAO,CAAR,CAAA,IAAc,CAAd,GAAkB,CAAC,CAAC,CAAD,CAAD,IAAQ,CAJ9C;QAKA,YAAA,EAAoB,CAAC,CAAC,CAAC,CAAD,CAAD,GAAO,GAAR,CAAA,IAAgB,EAAhB,GAAqB,CAAC,CAAC,CAAD,CAAD,IAAQ,CAA7B,GAAiC,CAAC,CAAC,CAAD,CAAD,IAAQ,CAL7D;QAMA,eAAA,EAAoB,CAAC,CAAC,CAAC,CAAD,CAAD,GAAO,IAAR,CAAA,IAAiB,CAAjB,GAAqB,CAAC,CAAC,CAAD,CAAD,IAAQ,CANjD;QAOA,gBAAA,EAAoB,CAAC,CAAC,CAAC,CAAD,CAAD,GAAO,GAAR,CAAA,GAAe,CAPnC;QASA,YAAA,EAAoB,EATpB;QAUA,QAAA,EAAoB,CAVpB;QAWA,cAAA,EAAoB,CAXpB;QAYA,QAAA,EAAoB,CAZpB;QAaA,UAAA,EAAoB;MAbpB,EAVZ;;MA2BQ,MAAM,CAAC,YAAP,GAA0B,QAAQ,CAAE,MAAM,CAAC,OAAT;MAClC,MAAM,CAAC,QAAP,GAA0B,cAAc,CAAE,MAAM,CAAC,cAAT;MACxC,MAAM,CAAC,cAAP,GAA0B,MAAM,CAAC,WAAP,GAAqB;MAC/C,MAAM,CAAC,QAAP,GAA0B,CAAE,CAAA,GAAI,MAAM,CAAC,cAAb,CAAA,GAAgC;MAC1D,MAAM,CAAC,UAAP,GAA0B,CAAC,KAAD,EAAO,MAAM,CAAC,WAAd,EAA0B,MAAM,CAAC,OAAjC,EAAyC,MAAM,CAAC,QAAhD,CAAyD,CAAC,IAA1D,CAA+D,GAA/D;aAE1B;IAlCQ;;EA9NC;;EAEb,UAAA,GAAa,IAAI,MAAM,CAAC,UAAX,CAAsB,CAAtB",
  "sourcesContent": [
    "strtok = require('strtok2')\r\nassert = require(\"assert\")\r\n\r\nPROFILES = [\r\n    \"Null\",\r\n    \"AAC Main\"\r\n    \"AAC LC\"\r\n    \"AAC SSR\"\r\n    \"AAC LTP\"\r\n    \"SBR\"\r\n    \"AAC Scalable\"\r\n    \"TwinVQ\"\r\n]\r\n\r\nSAMPLE_FREQUENCIES = [\r\n    96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350\r\n]\r\n\r\nCHANNEL_COUNTS = [\r\n    0,1,2,3,4,5,6,8\r\n]\r\n\r\nMPEG_HEADER_LENGTH  = 4\r\nID3V2_HEADER_LENGTH = 10\r\n\r\nMPEG_HEADER             = new strtok.BufferType(MPEG_HEADER_LENGTH)\r\nREST_OF_ID3V2_HEADER    = new strtok.BufferType(ID3V2_HEADER_LENGTH - MPEG_HEADER_LENGTH)\r\n\r\nmodule.exports = class AAC extends require(\"stream\").Writable\r\n\r\n    FIRST_BYTE = new strtok.BufferType(1)\r\n\r\n    constructor: ->\r\n        super()\r\n\r\n        # create an internal stream to pass to strtok\r\n        @istream = new (require(\"events\").EventEmitter)\r\n\r\n        @_flushing = false\r\n\r\n        # set up status\r\n        @frameSize  = -1\r\n        @beginning  = true\r\n        @gotFF      = false\r\n        @byteTwo    = null\r\n        @isCRC      = false\r\n        @gotID3     = 0\r\n\r\n        @frameHeader    = null\r\n        @frameHeaderBuf = null\r\n\r\n        @id3v2              = null\r\n        @_parsingId3v2      = false\r\n        @_finishingId3v2    = false\r\n        @_id3v2_1           = null\r\n        @_id3v2_2           = null\r\n\r\n        @once \"finish\", =>\r\n            @_flushing = setTimeout =>\r\n                @emit \"end\"\r\n            , 500\r\n\r\n        _emitAndMaybeEnd = (args...) =>\r\n            @emit args...\r\n\r\n            if @_flushing\r\n                clearTimeout @_flushing\r\n                @_flushing = setTimeout =>\r\n                    @emit \"end\"\r\n                , 500\r\n\r\n        strtok.parse @istream, (v,cb) =>\r\n            # -- initial request -- #\r\n\r\n            if v == undefined\r\n                # we need to examine each byte until we get a FF\r\n                return FIRST_BYTE\r\n\r\n            # -- ID3v2 tag -- #\r\n\r\n            if @_parsingId3v2\r\n                # we'll already have @id3v2 started with versionMajor and\r\n                # our first byte in @_id3v2_1\r\n\r\n                @id3v2.versionMinor = v[0]\r\n                @id3v2.flags = v[1]\r\n\r\n                # calculate the length\r\n                @id3v2.length =  (v[5] & 0x7f) | (( v[4] & 0x7f ) << 7) | (( v[3] & 0x7f ) << 14) | (( v[2] & 0x7f ) << 21)\r\n\r\n                @_parsingId3v2 = false;\r\n                @_finishingId3v2 = true;\r\n                @_id3v2_2 = v;\r\n\r\n                return new strtok.BufferType @id3v2.length\r\n\r\n            if @_finishingId3v2\r\n                # step 3 in the ID3v2 parse...\r\n                b = Buffer.concat([@_id3v2_1, @_id3v2_2, v])\r\n                _emitAndMaybeEnd 'id3v2', b\r\n\r\n                @_finishingId3v2 = false\r\n\r\n                return FIRST_BYTE;\r\n\r\n            # -- frame header -- #\r\n\r\n            if @frameSize == -1 && @frameHeader\r\n                # we're on-schedule now... we've had a valid frame.\r\n                # buffer should be seven or nine bytes\r\n\r\n                tag = v.toString 'ascii', 0, 3\r\n\r\n                if tag == 'ID3'\r\n                    # parse ID3v2 tag\r\n                    _emitAndMaybeEnd \"debug\", \"got an ID3\"\r\n                    @_parsingId3v2 = true\r\n                    @id3v2 = versionMajor:v[3]\r\n                    @_id3v2_1 = v\r\n\r\n                    return REST_OF_ID3V2_HEADER\r\n                else\r\n                    try\r\n                        h = @parseFrame(v)\r\n                    catch e\r\n                        # uh oh...  bad news\r\n                        console.log \"invalid header... \", v, @frameHeader\r\n                        @frameHeader = null\r\n                        return FIRST_BYTE\r\n\r\n                    @frameHeader    = h\r\n                    @frameHeaderBuf = v\r\n                    _emitAndMaybeEnd \"header\", h\r\n                    @frameSize = @frameHeader.frame_length\r\n\r\n                    if @frameSize == 1\r\n                        # problem...  just start over\r\n                        console.log \"Invalid frame header: \", h\r\n                        return FIRST_BYTE\r\n                    else\r\n                        return new strtok.BufferType(@frameSize - v.length);\r\n\r\n            # -- first header -- #\r\n\r\n            if @gotFF and @byteTwo\r\n                buf = Buffer.alloc(2+v.length)\r\n                buf[0] = 0xFF\r\n                buf[1] = @byteTwo\r\n                v.copy(buf,2)\r\n\r\n                try\r\n                    h = @parseFrame(buf)\r\n                catch e\r\n                    # invalid header...  chuck everything and try again\r\n                    console.log \"chucking invalid try at header: \", buf\r\n                    @gotFF = false\r\n                    @byteTwo = null\r\n                    return FIRST_BYTE\r\n\r\n                # valid header...  we're on schedule now\r\n                @gotFF = false\r\n                @byteTwo = null\r\n                @beginning = false\r\n\r\n                @frameHeader    = h\r\n                @frameHeaderBuf = buf\r\n                _emitAndMaybeEnd \"header\", h\r\n                @frameSize = @frameHeader.frame_length\r\n\r\n                @isCRC = h.crc\r\n\r\n                if @frameSize == 1\r\n                    # problem...  just start over\r\n                    console.log \"Invalid frame header: \", h\r\n\r\n                    return FIRST_BYTE\r\n                else\r\n                    #console.log \"On-tracking with frame of: \", @frameSize - buf.length\r\n                    return new strtok.BufferType(@frameSize - buf.length);\r\n\r\n            if @gotFF\r\n                if v[0]>>4 == 0xF\r\n                    @byteTwo = v[0]\r\n\r\n                    # make sure the layer bits are zero...  still need to make\r\n                    # sure we're on a valid header\r\n\r\n                    if (v[0] & 6) == 0\r\n                        # good... both zeros...\r\n\r\n                        # we need to figure out whether we're looking for CRC.  If\r\n                        # not, we need five more bytes for the header.  If so, we\r\n                        # need seven more. 1 == No CRC, 0 == CRC\r\n\r\n                        return new strtok.BufferType( if (v[0] & 1) == 1 then 5 else 7 )\r\n                    else\r\n                        @gotFF = false\r\n\r\n                else\r\n                    @gotFF = false\r\n\r\n            if @frameSize == -1 && !@gotFF\r\n                if v[0] == 0xFF\r\n                    # possible start of frame header. need next byte to know more\r\n                    @gotFF = true\r\n                    return FIRST_BYTE\r\n                else if v[0] == 0x49\r\n                    # could be the I in ID3\r\n                    @gotID3 = 1\r\n                    return FIRST_BYTE\r\n\r\n                else if @gotID3 == 1 && v[0] == 0x44\r\n                    @gotID3 = 2\r\n                    return FIRST_BYTE\r\n\r\n                else if @gotID3 == 2 && v[0] == 0x33\r\n                    @gotID3 = 3\r\n                    return FIRST_BYTE\r\n\r\n                else if @gotID3 == 3\r\n                    @_id3v2_1 = Buffer.from([0x49,0x44,0x33,v[0]])\r\n                    @id3v2 = versionMajor:v[0]\r\n                    @_parsingId3v2 = true\r\n                    @gotID3 = 0\r\n                    return REST_OF_ID3V2_HEADER\r\n                else\r\n                    # keep looking\r\n                    return FIRST_BYTE\r\n\r\n            # -- data frame -- #\r\n\r\n            if @frameHeaderBuf\r\n                frame = Buffer.alloc( @frameHeaderBuf.length + v.length )\r\n                @frameHeaderBuf.copy(frame,0)\r\n                v.copy(frame,@frameHeaderBuf.length)\r\n                _emitAndMaybeEnd \"frame\", frame, @frameHeader\r\n\r\n            @frameSize = -1\r\n\r\n            # what's next depends on whether we've been seeing CRC\r\n            return new strtok.BufferType( if @isCRC then 9 else 7 )\r\n\r\n    #----------\r\n\r\n    _write: (chunk,encoding,callback) ->\r\n        @istream.emit \"data\", chunk\r\n        callback?()\r\n\r\n    #----------\r\n\r\n    parseFrame: (b) ->\r\n        assert.ok Buffer.isBuffer(b)\r\n        assert.ok b.length >=7\r\n\r\n        # -- first twelve bits must be FFF -- #\r\n\r\n        assert.ok ( b[0] == 0xFF && (b[1] >> 4) == 0xF ), \"Buffer does not start with FFF\"\r\n\r\n        # -- set up our object -- #\r\n\r\n        header =\r\n            crc:                !(b[1] & 0x1)\r\n            mpeg_type:          if (b[1] & 0x8) then \"MPEG2\" else \"MPEG4\"\r\n            profile:            (b[2] >> 6) + 1\r\n            sample_freq:        SAMPLE_FREQUENCIES[ b[2] >> 2 & 0xF ]\r\n            channel_config:     (b[2] & 1) << 2 | b[3] >> 6\r\n            frame_length:       (b[3] & 0x3) << 11 | b[4] << 3 | b[5] >> 5\r\n            buffer_fullness:    (b[5] & 0x1F) << 6 | b[6] >> 2\r\n            number_of_frames:   (b[6] & 0x3) + 1\r\n\r\n            profile_name:       \"\"\r\n            channels:           0\r\n            frames_per_sec:     0\r\n            duration:           0\r\n            stream_key:         \"\"\r\n\r\n        # -- fill in remaining values -- #\r\n\r\n        header.profile_name     = PROFILES[ header.profile ]\r\n        header.channels         = CHANNEL_COUNTS[ header.channel_config ]\r\n        header.frames_per_sec   = header.sample_freq / 1024\r\n        header.duration         = ( 1 / header.frames_per_sec ) * 1000\r\n        header.stream_key       = ['aac',header.sample_freq,header.profile,header.channels].join(\"-\")\r\n\r\n        header\r\n"
  ]
}