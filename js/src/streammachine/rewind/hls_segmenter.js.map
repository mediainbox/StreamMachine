{
  "version": 3,
  "file": "hls_segmenter.js",
  "sourceRoot": "../../../../src/streammachine/rewind/",
  "sources": [
    "hls_segmenter.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "_           = require \"underscore\"\r\ntz          = require 'timezone'\r\nDebounce    = require \"../util/debounce\"\r\n\r\n# -- HTTP Live Streaming Segmenter -- #\r\n\r\n# each segment would include:\r\n# id:       timestamp\r\n# duration: cumulative timestamp\r\n# buffers:  array of buffer refs\r\n# header:   computed ID3 header\r\n\r\nMAX_PTS = Math.pow(2,33) - 1\r\n\r\nmodule.exports = class HLSSegmenter extends require(\"events\").EventEmitter\r\n    constructor: (@rewind,@segment_length,@log) ->\r\n        super()\r\n\r\n        @segments = []\r\n        @_rewindLoading = false\r\n\r\n        # Injector creates segment objects out of audio chunks. It doesn't\r\n        # do segment IDs, ordering or discontinuities\r\n        @injector = new HLSSegmenter.Injector @segment_length * 1000, @log\r\n\r\n\r\n        # Finalizer takes the half-baked segments, gives them IDs and puts them\r\n        # in the correct order. We defer loading the finalizer object until\r\n        # either a) data starts coming into the injector or b) we get a map\r\n        # loaded\r\n\r\n        @_snapDebounce = new Debounce 1000, =>\r\n            @finalizer.snapshot (err,snap) =>\r\n                @emit \"snapshot\", segment_duration:@segment_length,segments:snap\r\n\r\n        @finalizer = null\r\n\r\n        @_createFinalizer = _.once (map) =>\r\n            @finalizer = new HLSSegmenter.Finalizer @log, @segment_length * 1000, map\r\n            @injector.pipe(@finalizer)\r\n            @segments = @finalizer.segments\r\n\r\n            @finalizer.on \"add\", => @_snapDebounce.ping()\r\n            @finalizer.on \"remove\", =>\r\n                @_snapDebounce.ping()\r\n                @group?.hlsUpdateMinSegment Number(@segments[0].ts) if !@_rewindLoading && @segments[0]\r\n\r\n            @emit \"_finalizer\"\r\n\r\n        @injector.once \"readable\", =>\r\n            # we'll give one more second for a map to come in. Data will just\r\n            # queue up in the injector\r\n            setTimeout =>\r\n                @_createFinalizer()\r\n            , 1000\r\n\r\n        # The RewindBuffer can get data simultaneously inserted from two\r\n        # directions.  New live data will be emitted as an rpush and will\r\n        # go forward in timestamp.  Loading buffer data will be emitted\r\n        # as an runshift and will go backward in time. We need to listen\r\n        # and construct segments for each.\r\n\r\n        @rewind.on \"rpush\",     (c) => @injector.write c\r\n        @rewind.on \"runshift\",  (c) => @injector.write c\r\n\r\n        @rewind.on \"rshift\", (chunk) =>\r\n            # Data is being removed from the rewind buffer.  we should\r\n            # clean up our segments as needed\r\n\r\n            @finalizer?.expire chunk.ts, (err,seg_id) =>\r\n                if err\r\n                    @log.error \"Error expiring audio chunk: #{err}\"\r\n                    return false\r\n\r\n        # This event is triggered when RewindBuffer gets a call to loadBuffer.\r\n        # We use it to make sure we don't emit an UpdateMinSegment call while\r\n        # we're still loading backwards\r\n        @rewind.once \"rewind_loading\", =>\r\n            @_rewindLoading = true\r\n\r\n        # This event is triggered when RewindBuffer's loadBuffer is completed.\r\n        # Once we're done processing the data it received, we should update our\r\n        # group with our first segment ID.\r\n        @rewind.once \"rewind_loaded\", =>\r\n            # ask the injector to push any initial segment that it is holding\r\n            @injector._flush =>\r\n                @log.debug \"HLS Injector flushed\"\r\n\r\n                @once \"snapshot\", =>\r\n                    @log.debug \"HLS rewind loaded and settled. Length: #{@segments.length}\"\r\n                    @_rewindLoading = false\r\n\r\n                    if @segments[0]\r\n                        @group?.hlsUpdateMinSegment Number(@segments[0].ts)\r\n\r\n        @_gSyncFunc = (ts) =>\r\n            @finalizer?.setMinTS ts, (err,seg_id) =>\r\n                @log.debug \"Synced min segment TS to #{ts}. Got #{seg_id}.\"\r\n\r\n    #----------\r\n\r\n    syncToGroup: (g=null) ->\r\n        if @group\r\n            @group.removeListener \"hls_update_min_segment\", @_gSyncFunc\r\n            @group = null\r\n\r\n        if g\r\n            @group = g\r\n            @group.addListener \"hls_update_min_segment\", @_gSyncFunc\r\n\r\n        true\r\n\r\n    #----------\r\n\r\n    _dumpMap: (cb) ->\r\n        # dump our sequence information and a segment map from the finalizer\r\n        if @finalizer\r\n            @finalizer.dumpMap cb\r\n        else\r\n            cb null, null\r\n\r\n    _loadMap: (map) ->\r\n        @_createFinalizer map\r\n\r\n    #----------\r\n\r\n    status: ->\r\n        status =\r\n            hls_segments:       @segments.length\r\n            hls_first_seg_id:   @segments[0]?.id\r\n            hls_first_seg_ts:   @segments[0]?.ts\r\n            hls_last_seg_id:    @segments[ @segments.length - 1 ]?.id\r\n            hls_last_seg_ts:    @segments[ @segments.length - 1 ]?.ts\r\n\r\n    #----------\r\n\r\n    snapshot: (cb) ->\r\n        if @finalizer\r\n            @finalizer.snapshot (err,segments) =>\r\n                cb null,\r\n                    segments:           segments\r\n                    segment_duration:   @segment_length\r\n        else\r\n            cb null, null\r\n\r\n    #----------\r\n\r\n    pumpSegment: (id,cb) ->\r\n        if seg = @segment_idx[ id ]\r\n            cb null, seg\r\n        else\r\n            cb new Error \"HTTP Live Streaming segment not found.\"\r\n\r\n    #----------\r\n\r\n    class @Injector extends require(\"stream\").Transform\r\n        constructor: (@segment_length,@log) ->\r\n            super objectMode:true\r\n\r\n            @first_seg  = null\r\n            @last_seg   = null\r\n\r\n        #----------\r\n\r\n        _transform: (chunk,encoding,cb) ->\r\n            if @last_seg && ( @last_seg.ts <= chunk.ts < @last_seg.end_ts )\r\n                # in our chunk going forward\r\n                @last_seg.buffers.push chunk\r\n                return cb()\r\n\r\n            else if @first_seg && ( @first_seg.ts <= chunk.ts < @first_seg.end_ts )\r\n                # in our chunk going backward\r\n                @first_seg.buffers.unshift chunk\r\n                return cb()\r\n\r\n            else if !@last_seg || (chunk.ts >= @last_seg.end_ts)\r\n                # create a new segment for it\r\n                seg = @_createSegment chunk.ts\r\n\r\n                return cb() if !seg\r\n\r\n                seg.buffers.push chunk\r\n\r\n                if !@first_seg\r\n                    @first_seg = @last_seg\r\n                else\r\n                    # send our previous segment off to be finalized\r\n                    if @last_seg\r\n                        @emit \"push\", @last_seg\r\n                        @push @last_seg\r\n\r\n                # stash our new last segment\r\n                @last_seg = seg\r\n\r\n                return cb()\r\n\r\n            else if !@first_seg || (chunk.ts < @first_seg.ts)\r\n                # create a new segment for it\r\n                seg = @_createSegment chunk.ts\r\n\r\n                return cb() if !seg\r\n\r\n                seg.buffers.push chunk\r\n\r\n                # send our previous first segment off to be finalized\r\n                if @first_seg\r\n                    @emit \"push\", @first_seg\r\n                    @push @first_seg\r\n\r\n                # stash our new first segment\r\n                @first_seg = seg\r\n\r\n                return cb()\r\n\r\n            else\r\n                @log.error \"Not sure where to place segment!!! \", chunk_ts: chunk.ts\r\n                cb()\r\n\r\n        #----------\r\n\r\n        _flush: (cb) ->\r\n            # if either our first or last segments are \"complete\", go ahead and\r\n            # emit them\r\n\r\n            for seg in [@first_seg,@last_seg]\r\n                if seg\r\n                    duration = 0\r\n                    duration += b.duration for b in seg.buffers\r\n                    @log.debug \"HLS Injector flush checking segment: #{seg.ts}, #{duration}\"\r\n\r\n                    if duration >= @segment_length\r\n                        @emit \"push\", seg\r\n                        @push seg\r\n\r\n            cb()\r\n\r\n        #----------\r\n\r\n        _createSegment: (ts) ->\r\n            # There are two scenarios when we're creating a segment:\r\n            # 1) We have a segment map in memory, and we will return IDs from that\r\n            #    map for segments that already have them assigned. This is the case\r\n            #    if we're loading data back into memory.\r\n            # 2) We're creating new segments, and should be incrementing the\r\n            #    @_segmentSeq as we go.\r\n\r\n            seg_start = Math.floor( Number(ts) / @segment_length ) * @segment_length\r\n\r\n            # id will be filled in when we go to finalize\r\n            id:         null\r\n            ts:         new Date( seg_start )\r\n            end_ts:     new Date( seg_start + @segment_length)\r\n            buffers:    []\r\n\r\n    #----------\r\n\r\n    class @Finalizer extends require(\"stream\").Writable\r\n        constructor: (@log,@segmentLen,seg_data=null) ->\r\n            super objectMode:true\r\n\r\n            @segments       = []\r\n            @segment_idx    = {}\r\n\r\n            @segmentSeq         = seg_data?.segmentSeq || 0\r\n            @discontinuitySeq   = seg_data?.discontinuitySeq || 0\r\n            @firstSegment       = if seg_data?.nextSegment then Number(seg_data?.nextSegment) else null\r\n            @segment_map        = seg_data?.segmentMap || {}\r\n\r\n            @segmentPTS         = seg_data?.segmentPTS || (@segmentSeq * (@segmentLen*90))\r\n\r\n            # this starts out the same and diverges backward\r\n            @discontinuitySeqR  = @discontinuitySeq\r\n\r\n            @_min_ts        = null\r\n\r\n\r\n        #----------\r\n\r\n        expire: (ts,cb) ->\r\n            # expire any segments whose start ts values are at or below this given ts\r\n            loop\r\n                if (f_s = @segments[0])? && Number(f_s.ts) <= Number(ts)\r\n                    @segments.shift()\r\n                    delete @segment_idx[ f_s.id ]\r\n                    @emit \"remove\", f_s\r\n                else\r\n                    break\r\n\r\n            cb null, @segments[0]?.id\r\n\r\n        #----------\r\n\r\n        setMinTS: (ts,cb) ->\r\n            ts = Number(ts) if ts instanceof Date\r\n\r\n            @_min_ts = ts\r\n\r\n            # Don't expire a segment with this min TS. Send expire a number one lower.\r\n            @expire ts - 1, cb\r\n\r\n        #----------\r\n\r\n        dumpMap: (cb) ->\r\n            seg_map = {}\r\n            for seg in @segments\r\n                if !seg.discontinuity?\r\n                    seg_map[ Number( seg.ts ) ] = seg.id\r\n\r\n            map =\r\n                segmentMap:         seg_map\r\n                segmentSeq:         @segmentSeq\r\n                segmentLen:         @segmentLen\r\n                segmentPTS:         @segmentPTS\r\n                discontinuitySeq:   @discontinuitySeq\r\n                nextSegment:        @segments[ @segments.length - 1 ]?.end_ts\r\n\r\n            cb null, map\r\n\r\n        #----------\r\n\r\n        snapshot: (cb) ->\r\n            snapshot = @segments.slice(0)\r\n            cb null, snapshot\r\n\r\n        #----------\r\n\r\n        _write: (segment,encoding,cb) ->\r\n            # stash our last segment for convenience\r\n            last_seg = if @segments.length > 0 then @segments[ @segments.length - 1 ] else null\r\n\r\n            # -- Compute Segment ID -- #\r\n\r\n            seg_id  = null\r\n            seg_pts = null\r\n            if @segment_map[ Number(segment.ts) ]?\r\n                seg_id = @segment_map[ Number(segment.ts) ]\r\n                @log.debug \"Pulling segment ID from loaded segment map\", id:seg_id, ts:segment.ts\r\n\r\n                # don't create a segment we've been told not to have\r\n                if @_min_ts && segment.end_ts < @_min_ts\r\n                    @log.debug \"Discarding segment below our minimum TS.\", segment_id:seg_id, min_ts:@_min_ts\r\n                    cb()\r\n                    return false\r\n\r\n            else\r\n                # with incrementing segment numbers, we can only create the segment\r\n                # if our timestamp is after any existing segments. We shouldn't get\r\n                # here if it isn't, but if we were to, we would have to throw it out\r\n                if (!last_seg && (!@firstSegment || Number(segment.ts) > @firstSegment)) || (last_seg && Number(segment.ts) > Number(last_seg.ts))\r\n                    seg_id = @segmentSeq\r\n                    @segmentSeq += 1\r\n                else\r\n                    @log.debug \"Discarding segment without ID from front of buffer.\", segment_ts:segment.ts\r\n                    cb()\r\n                    return false\r\n\r\n            segment.id      = seg_id\r\n\r\n            # -- Compute Actual Start, End and Duration -- #\r\n\r\n            sorted_buffers  = _(segment.buffers).sortBy(\"ts\")\r\n            last_buf        = sorted_buffers[ sorted_buffers.length - 1 ]\r\n\r\n            segment.ts_actual       = sorted_buffers[0].ts\r\n            segment.end_ts_actual   = new Date( Number(last_buf.ts) + last_buf.duration )\r\n\r\n            duration        = 0\r\n            data_length     = 0\r\n\r\n            for b in sorted_buffers\r\n                duration    += b.duration\r\n                data_length += b.data.length\r\n\r\n            segment.data_length = data_length\r\n            segment.duration    = duration\r\n\r\n\r\n            # we don't need the actual data any more. The HLSIndex will look the\r\n            # data up in the RewindBuffer based on the timestamps\r\n            delete segment.buffers\r\n\r\n            # FIXME: This logic for this should be based on the target segment duration\r\n            segment.ts      = segment.ts_actual     if Math.abs( segment.ts - segment.ts_actual ) > 3000\r\n            segment.end_ts  = segment.ts_end_actual if Math.abs( segment.end_ts - segment.ts_end_actual ) > 3000\r\n\r\n            # -- Look for Gaps -- #\r\n\r\n            # our segment's .ts should align exactly on the .end_ts of the\r\n            # adjacent segment (or vice-versa, if we're loading backward). If it\r\n            # doesn't, we have a discontinuity, and we need to increment our\r\n            # segment's discontinuity sequence\r\n\r\n            if !last_seg || Number(segment.ts) > last_seg.ts\r\n                # we're comparing our .ts to last_seg's .end_ts\r\n\r\n                segment.discontinuitySeq =\r\n                    if !last_seg || segment.ts - last_seg.end_ts == 0\r\n                        @discontinuitySeq\r\n                    else\r\n                        @discontinuitySeq += 1\r\n\r\n                # for forward-facing segments, PTS is fetched from the finalizer, and then\r\n                # updated with our duration\r\n                segment.pts = @segmentPTS\r\n\r\n                @segmentPTS = Math.round(@segmentPTS + (segment.duration * 90))\r\n\r\n                # if new PTS is above 33-bit max, roll over\r\n                if @segmentPTS > MAX_PTS\r\n                    @segmentPTS = @segmentPTS - MAX_PTS\r\n\r\n                @segments.push segment\r\n\r\n            else if Number(segment.ts) < @segments[0].ts\r\n                # we're comparing our .end_ts to first segment's .ts\r\n\r\n                segment.discontinuitySeq =\r\n                    if segment.end_ts - @segments[0].ts == 0\r\n                        @discontinuitySeqR\r\n                    else\r\n                        @discontinuitySeqR -= 1\r\n\r\n                # segmentPTS will be the PTS of the following segment, minus our duration\r\n                segment.pts = Math.round(\r\n                    if @segments[0].pts > (segment.duration * 90)\r\n                        @segments[0].pts - (segment.duration * 90)\r\n                    else\r\n                        MAX_PTS - (segment.duration * 90) + @segments[0].pts\r\n                )\r\n\r\n                @segments.unshift segment\r\n\r\n            # add the segment to our index lookup\r\n            @segment_idx[ segment.id ] = segment\r\n\r\n            @emit \"add\", segment\r\n\r\n            cb()\r\n"
  ]
}