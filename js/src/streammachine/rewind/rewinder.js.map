{
  "version": 3,
  "file": "rewinder.js",
  "sourceRoot": "../../../../src/streammachine/rewind/",
  "sources": [
    "rewinder.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "_ = require \"underscore\"\r\n\r\ndebug = require(\"debug\")(\"sm:rewind:rewinder\")\r\n\r\n# Rewinder is the general-purpose listener stream.\r\n# Arguments:\r\n# * offset: Number\r\n#   - Where to position the playHead relative to now.  Should be a positive\r\n#     number representing the number of seconds behind live\r\n# * pump: Boolean||Number\r\n#   - If true, burst 30 seconds or so of data as a buffer. If offset is 0,\r\n#     that 30 seconds will effectively put the offset at 30. If offset is\r\n#     greater than 0, burst will go forward from that point.\r\n#   - If a number, specifies the number of seconds of data to pump\r\n#     immediately.\r\n# * pumpOnly: Boolean, default false\r\n#   - Don't hook the Rewinder up to incoming data. Pump whatever data is\r\n#     requested and then send EOF\r\n\r\nmodule.exports = class Rewinder extends require(\"stream\").Readable\r\n    constructor: (@rewind,@conn_id,opts={},cb) ->\r\n        # allow up to 256k in our read buffer before pausing\r\n        super highWaterMark:256*1024\r\n\r\n        # keep track of the duration of the segments we have pushed\r\n        # Note that for non-pump requests, these will be reset periodically\r\n        # as we report listening segments\r\n        @_sentDuration  = 0\r\n        @_sentBytes     = 0\r\n        @_offsetSeconds = null\r\n        @_contentTime   = null\r\n\r\n        @_pumpOnly = false\r\n\r\n        @_offset = -1\r\n\r\n        @_queue = []\r\n        @_queuedBytes = 0\r\n\r\n        @_reading = false\r\n        @_bounceRead = _.debounce =>\r\n            @read 0\r\n        , 100\r\n\r\n        @_segTimer = null\r\n\r\n        @pumpSecs = if opts.pump == true then @rewind.opts.burst else opts.pump\r\n\r\n        finalizeFunc = (args...) =>\r\n            # Logging\r\n            if !@_pumpOnly\r\n                # for non-pump requests, we want to set a timer that will\r\n                # log a segment every 30 seconds. This allows us to use the\r\n                # same analytics pipeline as we do for HLS pumped data\r\n                @_segTimer = setInterval =>\r\n                    obj =\r\n                        id:             @conn_id\r\n                        bytes:          @_sentBytes\r\n                        seconds:        @_sentDuration\r\n                        contentTime:    @_contentTime\r\n\r\n                    @emit \"listen\", obj\r\n                    @rewind.recordListen obj\r\n\r\n                    # reset our stats\r\n                    @_sentBytes     = 0\r\n                    @_sentDuration  = 0\r\n                    @_contentTime   = null\r\n\r\n                , opts.logInterval || 30*1000\r\n\r\n            cb null, @, args...\r\n            finalizeFunc = null\r\n            cb = null\r\n\r\n        oFunc = (@_offset) =>\r\n            debug \"Rewinder: creation with \", opts:opts, offset:@_offset\r\n\r\n            # -- What are we sending? -- #\r\n\r\n            if opts?.live_segment\r\n                # we're sending a segment of HTTP Live Streaming data\r\n                @_pumpOnly = true\r\n                @rewind.hls.pumpSegment @, opts.live_segment, (err,info) =>\r\n                    return cb err if err\r\n\r\n                    debug \"Pumping HLS segment with \", duration:info.duration, length:info.length, offsetSeconds:info.offsetSeconds\r\n\r\n                    @_offsetSeconds = info.offsetSeconds\r\n\r\n                    finalizeFunc info\r\n\r\n            else if opts?.pumpOnly\r\n                # we're just giving one pump of data, then EOF\r\n                @_pumpOnly = true\r\n                @rewind.pumpFrom @, @_offset, @rewind.secsToOffset(@pumpSecs), false, (err,info) =>\r\n                    return cb err if err\r\n\r\n                    # return pump information\r\n                    finalizeFunc info\r\n\r\n            else if opts?.pump\r\n                if @_offset == 0\r\n                    # pump some data before we start regular listening\r\n                    debug \"Rewinder: Pumping #{@rewind.opts.burst} seconds.\"\r\n                    @rewind.pumpSeconds @, @pumpSecs, true\r\n\r\n                    finalizeFunc()\r\n                else\r\n                    # we're offset, so we'll pump from the offset point forward instead of\r\n                    # back from live\r\n                    @rewind.burstFrom @, @_offset, @pumpSecs, (err,new_offset) =>\r\n                        return cb err if err\r\n\r\n                        @_offset = new_offset\r\n\r\n                        finalizeFunc()\r\n\r\n            else\r\n                finalizeFunc()\r\n\r\n        if opts.timestamp\r\n            @rewind.findTimestamp opts.timestamp, (err,offset) =>\r\n                return cb err if err\r\n                oFunc offset\r\n\r\n        else\r\n            offset =\r\n                if opts.offsetSecs\r\n                    @rewind.checkOffsetSecs opts.offsetSecs\r\n                else if opts.offset\r\n                    @rewind.checkOffset opts.offset\r\n                else\r\n                    0\r\n\r\n            oFunc offset\r\n\r\n    #----------\r\n\r\n    onFirstMeta: (cb) ->\r\n        if @_queue.length > 0\r\n            cb? null, @_queue[0].meta\r\n        else\r\n            @once \"readable\", =>\r\n                cb? null, @_queue[0].meta\r\n\r\n    #----------\r\n\r\n    # Implement the guts of the Readable stream. For a normal stream,\r\n    # RewindBuffer will be calling _insert at regular ticks to put content\r\n    # into our queue, and _read takes the task of buffering and sending\r\n    # that out to the listener.\r\n\r\n    _read: (size) =>\r\n        # we only want one queue read going on at a time, so go ahead and\r\n        # abort if we're already reading\r\n        if @_reading\r\n            return false\r\n\r\n        # -- push anything queued up to size -- #\r\n\r\n        # set a read lock\r\n        @_reading = true\r\n\r\n        sent = 0\r\n\r\n        # Set up pushQueue as a function so that we can call it multiple\r\n        # times until we get to the size requested (or the end of what we\r\n        # have ready)\r\n\r\n        _pushQueue = =>\r\n            # -- Handle an empty queue -- #\r\n\r\n            # In normal operation, you can think of the queue as infinite,\r\n            # but not speedy.  If we've sent everything we have, we'll send\r\n            # out an empty string to signal that more will be coming.  On\r\n            # the other hand, in pump mode we need to send a null character\r\n            # to signal that we've reached the end and nothing more will\r\n            # follow.\r\n\r\n            _handleEmpty = =>\r\n                if @_pumpOnly\r\n                    @push null\r\n\r\n                else\r\n                    @push ''\r\n\r\n                @_reading = false\r\n                return false\r\n\r\n            # See if the queue is empty to start with\r\n            if @_queue.length == 0\r\n                return _handleEmpty()\r\n\r\n            # Grab a chunk off of the queued up buffer\r\n            next_buf = @_queue.shift()\r\n\r\n            # This shouldn't happen...\r\n            if !next_buf\r\n                @rewind.log.error \"Shifted queue but got null\", length:@_queue.length\r\n\r\n            @_queuedBytes   -= next_buf.data.length\r\n            @_sentBytes     += next_buf.data.length\r\n            @_sentDuration  += (next_buf.duration / 1000)\r\n\r\n\r\n            #debug \"Sent duration is now #{ @_sentDuration }\"\r\n\r\n\r\n            # Not all chunks will contain metadata, but go ahead and send\r\n            # ours out if it does\r\n            if next_buf.meta\r\n                @emit \"meta\", next_buf.meta\r\n\r\n            # Push the chunk of data onto our reader. The return from push\r\n            # will tell us whether to keep pushing, or whether we need to\r\n            # stop and wait for a drain event (basically wait for the\r\n            # reader to catch up to us)\r\n\r\n            if @push next_buf.data\r\n                sent += next_buf.data.length\r\n\r\n                if sent < size && @_queue.length > 0\r\n                    _pushQueue()\r\n                else\r\n                    if @_queue.length == 0\r\n                        _handleEmpty()\r\n\r\n                    else\r\n                        @push ''\r\n                        @_reading = false\r\n\r\n            else\r\n                # give a signal that we're here for more when they're ready\r\n                @_reading = false\r\n                @emit \"readable\"\r\n\r\n        _pushQueue()\r\n\r\n    #----------\r\n\r\n    _insert: (b) =>\r\n        @_queue.push b\r\n        @_queuedBytes += b.data.length\r\n\r\n        # we set contentTime the first time we find it unset, which will be\r\n        # either on our first insert or on our first insert after logging\r\n        # has happened\r\n        @_contentTime = b.ts if !@_contentTime\r\n\r\n        @_bounceRead() if !@_reading\r\n\r\n    #----------\r\n\r\n    # Set a new offset (in seconds)\r\n    setOffset: (offset) ->\r\n        # -- make sure our offset is good -- #\r\n\r\n        @_offset = @rewind.checkOffsetSecs offset\r\n\r\n        # clear out the data we had buffered\r\n        @_queue.slice(0)\r\n\r\n        if @_offset == 0\r\n            # pump some data before we start regular listening\r\n            debug \"Rewinder: Pumping #{@rewind.opts.burst} seconds.\"\r\n            @rewind.pumpSeconds @, @pumpSecs\r\n        else\r\n            # we're offset, so we'll pump from the offset point forward instead of\r\n            # back from live\r\n            [@_offset,data] = @rewind.burstFrom @_offset, @pumpSecs\r\n            @_queue.push data\r\n\r\n        @_offset\r\n\r\n    #----------\r\n\r\n    # Return the current offset in chunks\r\n    offset: ->\r\n        @_offset\r\n\r\n    #----------\r\n\r\n    # Return the current offset in seconds\r\n    offsetSecs: ->\r\n        @rewind.offsetToSecs @_offset\r\n\r\n    #----------\r\n\r\n    disconnect: ->\r\n        @rewind._rremoveListener @\r\n\r\n        # Record either a) our full listening session (pump requests) or\r\n        # b) the portion of the request that we haven't already recorded\r\n        # (non-pump requests)\r\n        obj =\r\n            id:             @conn_id\r\n            bytes:          @_sentBytes\r\n            seconds:        @_sentDuration\r\n            offsetSeconds:  @_offsetSeconds\r\n            contentTime:    @_contentTime\r\n\r\n        @emit \"listen\", obj\r\n        @rewind.recordListen obj\r\n\r\n        # clear our listen segment timer\r\n        clearInterval @_segTimer if @_segTimer\r\n\r\n        # This just takes the listener out of lmeta. This will probably go\r\n        # away at some point or be rolled into the function above\r\n        @rewind.disconnectListener @conn_id\r\n\r\n        # make sure we're freed up for GC\r\n        @removeAllListeners()\r\n\r\n\r\n#----------\r\n"
  ]
}