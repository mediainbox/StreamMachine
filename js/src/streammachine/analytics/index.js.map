{
  "version": 3,
  "file": "index.js",
  "sourceRoot": "../../../../src/streammachine/analytics/",
  "sources": [
    "index.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "_       = require \"underscore\"\r\nURL     = require \"url\"\r\nwinston = require \"winston\"\r\ntz      = require \"timezone\"\r\nnconf   = require \"nconf\"\r\n\r\ndebug = require(\"debug\")(\"sm:analytics\")\r\n\r\nAnalyticsEsStore = require \"./store/es_store\"\r\n\r\n# This module is responsible for:\r\n\r\n# * Listen for session_start and listen interactions\r\n# * Watch for sessions that are no longer active.  Finalize them, attaching\r\n#   stats and duration, and throwing out sessions that did not meet minimum\r\n#   requirements\r\n# * Answer questions about current number of listeners at any given time\r\n\r\nmodule.exports = class Analytics\r\n    constructor: (@ctx) ->\r\n        @logger = @ctx.logger.child(\r\n            component: \"analytics\"\r\n        )\r\n\r\n        @config = @ctx.config.analytics\r\n        @_timeout_sec = Number(@config.finalize_secs)\r\n\r\n        if @ctx.providers.redis\r\n            @redis = @ctx.providers.redis\r\n\r\n        # track open sessions\r\n        @sessions = {}\r\n\r\n        @local = tz(require \"timezone/zones\")(nconf.get(\"timezone\")||\"UTC\")\r\n\r\n\r\n        @store = new AnalyticsEsStore(@config, @ctx)\r\n\r\n        # -- are there any sessions that should be finalized? -- #\r\n        # when was our last finalized session?\r\n        #last_session = @influx.query \"SELECT max(time) from sessions\", (err,res) =>\r\n        #    console.log \"last session is \", err, res\r\n        # what sessions have we seen since then?\r\n\r\n        # -- Redis Session Sweep -- #\r\n        if @redis\r\n            @logger.info \"Analytics setting up Redis session sweeper\"\r\n\r\n            setInterval =>\r\n                # look for sessions that should be written (score less than now)\r\n                @redis.client.zrangebyscore \"session-timeouts\", 0, Math.floor( Number(new Date) / 1000), (err,sessions) =>\r\n                    return @logger.error \"Error fetching sessions to finalize: #{err}\" if err\r\n\r\n                    _sFunc = =>\r\n                        if s = sessions.shift()\r\n                            @_triggerSession s\r\n                            _sFunc()\r\n\r\n                    _sFunc()\r\n\r\n            , 5*1000\r\n\r\n    #----------\r\n\r\n    _log: (obj,cb) ->\r\n        session_id = null\r\n\r\n        if !obj.client?.session_id\r\n            cb? new Error \"Object does not contain a session ID\"\r\n            return false\r\n\r\n        # write one index per day of data\r\n        index_date = tz(obj.time,\"%F\")\r\n\r\n        time = new Date( obj.time )\r\n\r\n        # clean up IPv4 IP addresses stuck in IPv6\r\n        if obj.client?.ip\r\n            obj.client.ip = obj.client.ip.replace /^::ffff:/, \"\"\r\n\r\n        @_indicesForTimeRange \"listens\", time, (err,idx) =>\r\n            switch obj.type\r\n                when \"session_start\"\r\n                    @idx_batch.write index:idx[0], body:\r\n                        time:       new Date(obj.time)\r\n                        session_id: obj.client.session_id\r\n                        stream:     obj.stream_group || obj.stream\r\n                        client:     obj.client\r\n                        type:       \"start\"\r\n\r\n                    cb? null\r\n\r\n                    # -- start tracking the session -- #\r\n\r\n                when \"listen\"\r\n                    # do we know of other duration for this session?\r\n                    @_getStashedDurationFor obj.client.session_id, obj.duration, (err,dur) =>\r\n                        @idx_batch.write index:idx[0], body:\r\n                            session_id:         obj.client.session_id\r\n                            time:               new Date(obj.time)\r\n                            kbytes:             obj.kbytes\r\n                            duration:           obj.duration\r\n                            session_duration:   dur\r\n                            stream:             obj.stream\r\n                            client:             obj.client\r\n                            offsetSeconds:      obj.offsetSeconds\r\n                            contentTime:        obj.contentTime\r\n                            type:               \"listen\"\r\n\r\n                        cb? null\r\n\r\n            # -- update our timer -- #\r\n\r\n            @_updateSessionTimerFor obj.client.session_id, (err) =>\r\n\r\n    #----------\r\n\r\n    # Given a session id and duration, add the given duration to any\r\n    # existing cached duration and return the accumulated number\r\n    _getStashedDurationFor: (session,duration,cb) ->\r\n        if @redis\r\n            # use redis stash\r\n            key = \"duration-#{session}\"\r\n            @redis.client.incrby key, Math.round(duration), (err,res) =>\r\n                cb err, res\r\n\r\n            # set a TTL on our key, so that it doesn't stay indefinitely\r\n            @redis.client.pexpire key, 5*60*1000, (err) =>\r\n                @logger.error \"Failed to set Redis TTL for #{key}: #{err}\" if err\r\n\r\n        else\r\n            # use memory stash\r\n            s = @_ensureMemorySession session\r\n            s.duration += duration\r\n            cb null, s.duration\r\n\r\n    #----------\r\n\r\n    _updateSessionTimerFor: (session,cb) ->\r\n        if @_timeout_sec <= 0\r\n            # timeouts are disabled\r\n            return cb null\r\n\r\n        if @redis\r\n            # this will set the score, or update it if the session is\r\n            # already in the set\r\n            timeout_at = (Number(new Date) / 1000) + @_timeout_sec\r\n\r\n            @redis.client.zadd \"session-timeouts\", timeout_at, session, (err) =>\r\n                cb err\r\n\r\n        else\r\n            s = @_ensureMemorySession session\r\n\r\n            clearTimeout s.timeout if s.timeout\r\n\r\n            s.timeout = setTimeout =>\r\n                @_triggerSession session\r\n            , @_timeout_sec * 1000\r\n\r\n            cb null\r\n\r\n    #----------\r\n\r\n    _scrubSessionFor: (session,cb) ->\r\n        if @redis\r\n            @redis.client.zrem \"session-timeouts\", session, (err) =>\r\n                return cb err if err\r\n\r\n                @redis.client.del \"duration-#{session}\", (err) =>\r\n                    cb err\r\n\r\n        else\r\n           s = @_ensureMemorySession session\r\n           clearTimeout s.timeout if s.timeout\r\n           delete @sessions[session]\r\n\r\n           cb null\r\n\r\n\r\n    #----------\r\n\r\n    _ensureMemorySession: (session) ->\r\n        @sessions[ session ] ||=\r\n            duration:0, last_seen_at:Number(new Date()), timeout:null\r\n\r\n    #----------\r\n\r\n    _triggerSession: (session) ->\r\n        @_scrubSessionFor session, (err) =>\r\n            return @logger.error \"Error cleaning session cache: #{err}\" if err\r\n\r\n            @_finalizeSession session, (err,obj) =>\r\n                return @logger.error \"Error assembling session: #{err}\" if err\r\n\r\n                if obj\r\n                    @_storeSession obj, (err) =>\r\n                        @logger.error \"Error writing session: #{err}\" if err\r\n\r\n    #----------\r\n\r\n    countListeners: (cb) ->\r\n        return @store.countListeners(cb)\r\n\r\n    #----------\r\n\r\n    _finalizeSession: (id,cb) ->\r\n        @logger.debug \"Finalizing session for #{ id }\"\r\n\r\n        # This is a little ugly. We need to take several steps:\r\n        # 1) Have we ever finalized this session id?\r\n        # 2) Look up the session_start for the session_id\r\n        # 3) Compute the session's sent kbytes, sent duration, and elapsed duration\r\n        # 4) Write a session object\r\n\r\n        session = {}\r\n\r\n        # -- Get Started -- #\r\n\r\n        @_selectPreviousSession id, (err,ts) =>\r\n            if err\r\n                @logger.error err\r\n                return cb? err\r\n\r\n            @_selectSessionStart id, (err,start) =>\r\n                if err\r\n                    @logger.error err\r\n                    return cb err\r\n\r\n                if !start\r\n                    @logger.debug \"Attempt to finalize invalid session. No start event for #{id}.\"\r\n                    return cb null, false\r\n\r\n                @_selectListenTotals id, ts, (err,totals) =>\r\n                    if err\r\n                        @logger.error err\r\n                        return cb? err\r\n\r\n                    if !totals\r\n                        # Session did not have any recorded listen events.  Toss it.\r\n                        return cb null, false\r\n\r\n                    # -- build session -- #\r\n\r\n                    session =\r\n                        session_id: id\r\n                        output:     start.output\r\n                        stream:     start.stream\r\n                        time:       totals.last_listen\r\n                        start_time: ts || start.time\r\n                        client:     start.client\r\n                        kbytes:     totals.kbytes\r\n                        duration:   totals.duration\r\n                        connected:  ( Number(totals.last_listen) - Number(ts||start.time) ) / 1000\r\n\r\n                    cb null, session\r\n"
  ]
}