{
  "version": 3,
  "file": "transcoding.js",
  "sourceRoot": "../../../../src/streammachine/sources/",
  "sources": [
    "transcoding.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "_               = require \"underscore\"\r\nFFmpeg          = require \"fluent-ffmpeg\"\r\nPassThrough     = require(\"stream\").PassThrough\r\n\r\nDebounce        = require \"../util/debounce\"\r\n\r\ndebug = require(\"debug\")(\"sm:sources:transcoding\")\r\n\r\nmodule.exports = class TranscodingSource extends require(\"./base\")\r\n    TYPE: -> \"Transcoding (#{if @connected then \"Connected\" else \"Waiting\"})\"\r\n\r\n    constructor: (@opts) ->\r\n        super skipParser:true\r\n\r\n        @_disconnected = false\r\n\r\n        @d = require(\"domain\").create()\r\n        @d.on \"error\", (err) =>\r\n            @log?.error \"TranscodingSource domain error:\" + err\r\n            debug \"Domain error: #{err}\", err\r\n\r\n            @disconnect()\r\n\r\n        @d.run =>\r\n            @_queue = []\r\n\r\n            @o_stream = @opts.stream\r\n\r\n            @last_ts = null\r\n\r\n            # we start up an ffmpeg transcoder and then listen for data events\r\n            # from our source. Each time we get a chunk of audio data, we feed\r\n            # it into ffmpeg.  We then run the stream of transcoded data that\r\n            # comes back through our parser to re-chunk it. We count chunks to\r\n            # attach the right timing information to the chunks that come out\r\n\r\n            @_buf = new PassThrough\r\n            @ffmpeg = new FFmpeg( source:@_buf, captureStderr:false ).addOptions @opts.ffmpeg_args.split(\"|\")\r\n\r\n            @ffmpeg.on \"start\", (cmd) =>\r\n                @log?.info \"ffmpeg started with #{ cmd }\"\r\n\r\n            @ffmpeg.on \"error\", (err, stdout, stderr) =>\r\n                if err.code == \"ENOENT\"\r\n                    @log?.error \"ffmpeg failed to start.\"\r\n                    @disconnect()\r\n                else\r\n                    @log?.error \"ffmpeg transcoding error: #{ err }\"\r\n                    @log?.error \"ffmpeg transcoding error stdout: #{ stdout }\"\r\n                    @log?.error \"ffmpeg transcoding error stderr: #{ stderr }\"\r\n                    @disconnect()\r\n\r\n            @ffmpeg.writeToStream @parser\r\n\r\n            # -- watch for discontinuities -- #\r\n\r\n            @_pingData = new Debounce (@opts.discontinuityTimeout || 30*1000), (last_ts) =>\r\n                # data has stopped flowing. mark a discontinuity in the chunker.\r\n                @log?.info \"Transcoder data interupted. Marking discontinuity.\"\r\n                @emit \"discontinuity_begin\", last_ts\r\n\r\n                @o_stream.once \"data\", (chunk) =>\r\n                    @log?.info \"Transcoder data resumed. Reseting time to #{chunk.ts}.\"\r\n                    @emit \"discontinuity_end\", chunk.ts, last_ts\r\n                    @chunker.resetTime chunk.ts\r\n\r\n            # -- chunking -- #\r\n\r\n            @oDataFunc = (chunk) =>\r\n                @_pingData.ping()\r\n                @_buf.write chunk.data\r\n\r\n            @oFirstDataFunc = (first_chunk) =>\r\n                @emit \"connected\"\r\n                @connected = true\r\n\r\n                @oFirstDataFunc = null\r\n\r\n                @chunker = new TranscodingSource.FrameChunker @emitDuration * 1000, first_chunk.ts\r\n\r\n                @parser.on \"frame\", (frame,header) =>\r\n                    # we need to re-apply our chunking logic to the output\r\n                    @chunker.write frame:frame, header:header\r\n\r\n                @chunker.on \"readable\", =>\r\n                    while c = @chunker.read()\r\n                        @last_ts = c.ts\r\n                        @emit \"data\", c\r\n\r\n                @o_stream.on \"data\", @oDataFunc\r\n\r\n                @_buf.write first_chunk.data\r\n\r\n            @o_stream.once \"data\", @oFirstDataFunc\r\n\r\n            # -- watch for vitals -- #\r\n\r\n            @parser.once \"header\", (header) =>\r\n                # -- compute frames per second and stream key -- #\r\n\r\n                @framesPerSec   = header.frames_per_sec\r\n                @streamKey      = header.stream_key\r\n\r\n                @log?.debug \"setting framesPerSec to \", frames:@framesPerSec\r\n                @log?.debug \"first header is \", header\r\n\r\n                # -- send out our stream vitals -- #\r\n\r\n                @_setVitals\r\n                    streamKey:          @streamKey\r\n                    framesPerSec:       @framesPerSec\r\n                    emitDuration:       @emitDuration\r\n\r\n    #----------\r\n\r\n    status: ->\r\n        source:     @TYPE?() ? @TYPE\r\n        connected:  @connected\r\n        url:        \"N/A\"\r\n        streamKey:  @streamKey\r\n        uuid:       @uuid\r\n        last_ts:    @last_ts\r\n\r\n    #----------\r\n\r\n    disconnect: ->\r\n        if !@_disconnected\r\n            @_disconnected = true\r\n            @d.run =>\r\n                @o_stream.removeListener \"data\", @oDataFunc\r\n                @o_stream.removeListener \"data\", @oFirstDataFunc if @oFirstDataFunc\r\n                @ffmpeg.kill()\r\n                @_pingData?.kill()\r\n                @connected = false\r\n\r\n            @emit \"disconnect\"\r\n\r\n            @removeAllListeners()\r\n"
  ]
}