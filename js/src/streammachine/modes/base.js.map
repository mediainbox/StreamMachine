{
  "version": 3,
  "file": "base.js",
  "sourceRoot": "../../../../src/streammachine/modes/",
  "sources": [
    "base.coffee"
  ],
  "names": [],
  "mappings": "AAAA,IAAA,IAAA,EAAA,MAAA,EAAA,CAAA,EAAA;;AAAA,KAAA,GAAU,OAAA,CAAQ,OAAR;;AACV,MAAA,GAAU,OAAA,CAAQ,WAAR;;AACV,CAAA,GAAU,OAAA,CAAQ,YAAR;;AAEV,MAAM,CAAC,OAAP,GAAuB,OAAN,MAAA,KAAA,QAAmB,OAAA,CAAQ,QAAR,CAAiB,CAAC,aAArC;EACb,WAAa,KAAA,CAAA;;IAAC,IAAC,CAAA;IAGX,IAAC,CAAA,GAAD,GAAO,IAAI,MAAJ,CAAW,CAAC,CAAC,MAAF,CAAS,IAAC,CAAA,IAAI,CAAC,GAAf,EAAoB,KAAK,CAAC,GAAN,CAAU,KAAV,CAApB,CAAX,EAAkD,IAAC,CAAA,IAAI,CAAC,IAAxD,EAFf;;IAKQ,IAAC,CAAA,GAAG,CAAC,KAAL,CAAW,0CAAX;IAEA,IAAG,OAAO,CAAC,SAAR,CAAkB,SAAlB,CAA4B,CAAC,MAA7B,GAAsC,CAAzC;MACI,IAAC,CAAA,GAAG,CAAC,IAAL,CAAU,kFAAV,EADJ;KAAA,MAAA;;MAII,OAAO,CAAC,EAAR,CAAW,SAAX,EAAsB,CAAA,CAAA,GAAA;QAClB,IAAG,IAAC,CAAA,WAAJ;AACI,iBAAO,MADX;;QAGA,IAAC,CAAA,WAAD,GAAe;QAKf,IAAG,CAAC,IAAC,CAAA,IAAL;UACE,IAAC,CAAA,GAAG,CAAC,KAAL,CAAW,qFAAX;UACA,IAAC,CAAA,WAAD,GAAe;AACf,iBAAO,MAHT;;QAKA,IAAC,CAAA,GAAG,CAAC,IAAL,CAAU,uDAAV;eAEA,IAAC,CAAA,IAAI,CAAC,OAAN,CAAc,YAAd,EAA4B,IAA5B,EAAkC,IAAlC,EAAwC;UAAA,OAAA,EAAQ;QAAR,CAAxC,EAAuD,CAAC,GAAD,EAAK,KAAL,CAAA,GAAA;UACnD,IAAG,GAAH;YACI,IAAC,CAAA,GAAG,CAAC,KAAL,CAAW,CAAA,2BAAA,CAAA,CAA8B,GAA9B,CAAA,CAAX;YACA,IAAC,CAAA,WAAD,GAAe;AACf,mBAAO,MAHX;;UAKA,IAAC,CAAA,GAAG,CAAC,IAAL,CAAU,8CAAV;iBACA,IAAC,CAAA,YAAD,CAAc,IAAC,CAAA,IAAf;QAPmD,CAAvD;MAhBkB,CAAtB,EAJJ;;EARS,CAAjB;;;;;EAyCI,UAAY,CAAA,CAAA;AAChB,QAAA,CAAA,EAAA,GAAA,EAAA,OAAA,EAAA;AAAQ;AAAA;IAAA,KAAA,QAAA;;mBAAA,CAAC,CAAC,IAAF,CAAA;IAAA,CAAA;;EADQ;;AA1CC;;AAJjB",
  "sourcesContent": [
    "nconf   = require \"nconf\"\r\nLogger  = require \"../logger\"\r\n_       = require \"underscore\"\r\n\r\nmodule.exports = class Core extends require(\"events\").EventEmitter\r\n    constructor: (@opts) ->\r\n        super()\r\n\r\n        @log = new Logger _.extend(@opts.log, nconf.get('log')), @opts.mode\r\n\r\n        # see runner for restart trigger based on SIGUSR2\r\n        @log.debug \"Attaching listener for SIGUSR2 restarts.\"\r\n\r\n        if process.listeners(\"SIGUSR2\").length > 0\r\n            @log.info \"Skipping SIGUSR2 registration for handoffs since another listener is registered.\"\r\n        else\r\n            # Support a handoff trigger via USR2\r\n            process.on \"SIGUSR2\", =>\r\n                if @_restarting\r\n                    return false\r\n\r\n                @_restarting = true\r\n\r\n                # replacement process is spawned externally\r\n\r\n                # make sure there's an external process out there...\r\n                if !@_rpc\r\n                  @log.error \"StreamMachine process was asked for external handoff, but there is no RPC interface\"\r\n                  @_restarting = false\r\n                  return false\r\n\r\n                @log.info \"Sending process for USR2. Starting handoff via proxy.\"\r\n\r\n                @_rpc.request \"HANDOFF_GO\", null, null, timeout:20000, (err,reply) =>\r\n                    if err\r\n                        @log.error \"Error handshaking handoff: #{err}\"\r\n                        @_restarting = false\r\n                        return false\r\n\r\n                    @log.info \"Sender got handoff handshake. Starting send.\"\r\n                    @_sendHandoff @_rpc\r\n\r\n    #----------\r\n\r\n    # Build a hash of stream information, including sources and listener counts\r\n\r\n    streamInfo: ->\r\n        s.info() for k,s of @streams\r\n\r\n    #----------\r\n"
  ]
}