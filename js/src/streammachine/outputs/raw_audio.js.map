{
  "version": 3,
  "file": "raw_audio.js",
  "sourceRoot": "../../../../src/streammachine/outputs/",
  "sources": [
    "raw_audio.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "BaseOutput = require \"./base\"\r\n\r\ndebug = require(\"debug\")(\"sm:outputs:raw_audio\")\r\n\r\nmodule.exports = class RawAudio extends BaseOutput\r\n    constructor: (stream, opts) ->\r\n        super(\"raw\", stream, opts)\r\n\r\n        @disconnected = false\r\n\r\n        debug \"Incoming request.\"\r\n\r\n        @pump = true\r\n\r\n        if @opts.req && @opts.res\r\n            @client.offsetSecs  = @opts.req.query.offset || -1\r\n            @opts.res.chunkedEncoding = false\r\n            @opts.res.useChunkedEncodingByDefault = false\r\n\r\n            headers =\r\n                \"Content-Type\":\r\n                    if @stream.opts.format == \"mp3\"         then \"audio/mpeg\"\r\n                    else if @stream.opts.format == \"aac\"    then \"audio/aacp\"\r\n                    else \"unknown\"\r\n                \"Accept-Ranges\": \"none\"\r\n\r\n            # write out our headers\r\n            @opts.res.writeHead 200, headers\r\n            @opts.res._send ''\r\n\r\n            process.nextTick =>\r\n                @stream.startSession @client, (err,session_id) =>\r\n                    @client.session_id = session_id\r\n\r\n                    # -- send a preroll if we have one -- #\r\n                    if @stream.preroll && !@opts.req.query.preskip\r\n                        debug \"making preroll request on stream #{@stream.key}\"\r\n                        @stream.preroll.pump @, @socket,\r\n                            (err) => @connectToStream()\r\n                    else\r\n                        @connectToStream()\r\n\r\n        else if @opts.socket\r\n            # -- just the data -- #\r\n\r\n            @pump = false\r\n            process.nextTick => @connectToStream()\r\n\r\n        else\r\n            # fail\r\n            @stream.log.error \"Listener passed without connection handles or socket.\"\r\n\r\n        # register our various means of disconnection\r\n        @socket.on \"end\",   => @disconnect()\r\n        @socket.on \"close\", => @disconnect()\r\n        @socket.on \"error\", (err) =>\r\n            @stream.log.debug \"Got client socket error: #{err}\"\r\n            @disconnect()\r\n\r\n    #----------\r\n\r\n    disconnect: ->\r\n        super =>\r\n            @source?.disconnect()\r\n            @socket?.end() unless (@socket.destroyed)\r\n\r\n    #----------\r\n\r\n    prepForHandoff: (cb) ->\r\n        # remove the initial client.offsetSecs if it exists\r\n        delete @client.offsetSecs\r\n\r\n        cb?()\r\n\r\n    #----------\r\n\r\n    connectToStream: ->\r\n        unless @disconnected\r\n            debug \"Connecting to stream #{@stream.key}\"\r\n            @stream.listen @,\r\n                offsetSecs:     @client.offsetSecs,\r\n                offset:         @client.offset,\r\n                pump:           @pump,\r\n                startTime:      @opts.startTime,\r\n                (err,@source) =>\r\n                    if err\r\n                        if @opts.res?\r\n                            @opts.res.status(500).end err\r\n                        else\r\n                            @socket?.end()\r\n\r\n                        return false\r\n\r\n                    # update our offset now that it's been checked for availability\r\n                    @client.offset = @source.offset()\r\n\r\n                    @source.pipe @socket\r\n"
  ]
}