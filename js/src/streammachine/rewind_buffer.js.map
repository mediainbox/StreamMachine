{
  "version": 3,
  "file": "rewind_buffer.js",
  "sourceRoot": "../../../src/streammachine/",
  "sources": [
    "rewind_buffer.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "_           = require 'underscore'\r\nConcentrate = require \"concentrate\"\r\nDissolve    = require \"dissolve\"\r\nnconf       = require \"nconf\"\r\n\r\nRewinder        = require \"./rewind/rewinder\"\r\nHLSSegmenter    = require \"./rewind/hls_segmenter\"\r\n\r\nMemoryStore     = require \"./rewind/memory_store\"\r\n\r\n# RewindBuffer supports play from an arbitrary position in the last X hours\r\n# of our stream.\r\n\r\n# Buffer is an array of objects. Each object should have:\r\n# * ts:         Timestamp for when chunk was emitted from master stream\r\n# * data:       Chunk of audio data (in either MP3 or AAC)\r\n# * meta:       Metadata that should be running as of this chunk\r\n# * duration:   Duration of the audio chunk\r\n\r\n# When the buffer is dumped, it will be in the form of a loop of binary\r\n# packets.  Each will contain:\r\n# * uint8: metadata length\r\n# * Buffer: metadata, stringified into JSON and stuck in a buffer (obj is ts,\r\n#   duration and meta)\r\n# * uint16: data length\r\n# * Buffer: data chunk\r\n\r\nmodule.exports = class RewindBuffer extends require(\"events\").EventEmitter\r\n    constructor: (rewind_opts={}) ->\r\n        super()\r\n\r\n        @_rsecs         = rewind_opts.seconds || 0\r\n        @_rburstsecs    = rewind_opts.burst || 0\r\n        @_rsecsPerChunk = Infinity\r\n        @_rmax          = null\r\n        @_rburst        = null\r\n        @_rkey          = rewind_opts.key\r\n\r\n        @_risLoading    = false\r\n\r\n        # This could already be set if we've subclassed RewindBuffer, so\r\n        # only set it if it doesn't exist\r\n        @log            = rewind_opts.log if rewind_opts.log && !@log\r\n\r\n        # each listener should be an object that defines obj._offset and\r\n        # obj.writeFrame. We implement RewindBuffer.Listener, but other\r\n        # classes can work with those pieces\r\n        @_rlisteners = []\r\n\r\n        # -- instantiate our memory buffer -- #\r\n\r\n        @_rbuffer = rewind_opts.buffer_store || new MemoryStore\r\n        @_rbuffer.on \"shift\",    (b) => @emit \"rshift\", b\r\n        @_rbuffer.on \"push\",     (b) => @emit \"rpush\", b\r\n        @_rbuffer.on \"unshift\",  (b) => @emit \"runshift\", b\r\n\r\n        # -- set up Live Streaming segments -- #\r\n\r\n        if rewind_opts.hls\r\n            @log.debug \"Setting up HLS Segmenter.\", segment_duration:rewind_opts.hls\r\n            @hls_segmenter = new HLSSegmenter @, rewind_opts.hls, @log\r\n\r\n        # -- set up header and frame functions -- #\r\n\r\n        @_rdataFunc = (chunk) =>\r\n            # push the chunk on the buffer\r\n            @_rbuffer.insert chunk\r\n\r\n            # loop through all connected listeners and pass the frame buffer at\r\n            # their offset.\r\n            for l in @_rlisteners\r\n                # we'll give them whatever is at length - offset\r\n                # FIXME: This lookup strategy is horribly inefficient\r\n                @_rbuffer.at l._offset, (err,b) =>\r\n                    l._insert b\r\n\r\n        # -- look for stream connections -- #\r\n\r\n        @on \"source\", (newsource) =>\r\n            @_rConnectSource newsource\r\n\r\n    #----------\r\n\r\n    disconnect: ->\r\n        @_rdataFunc = ->\r\n        @_rbuffer.removeAllListeners()\r\n\r\n        true\r\n\r\n    #----------\r\n\r\n    isLoading: ->\r\n        @_risLoading\r\n\r\n    #----------\r\n\r\n    resetRewind: (cb) ->\r\n        @_rbuffer.reset cb\r\n        @emit \"reset\"\r\n\r\n    #----------\r\n\r\n    setRewind: (secs,burst) ->\r\n        @_rsecs = secs\r\n        @_rburstsecs = burst\r\n        @_rUpdateMax()\r\n\r\n    #----------\r\n\r\n    _rConnectSource: (newsource,cb) ->\r\n        @log.debug \"RewindBuffer got source event\"\r\n        # -- disconnect from old source -- #\r\n\r\n        if @_rsource\r\n            @_rsource.removeListener \"data\", @_rdataFunc\r\n            @log.debug \"removed old rewind data listener\"\r\n\r\n        # -- compute initial stats -- #\r\n\r\n        newsource.vitals (err,vitals) =>\r\n            if @_rstreamKey && @_rstreamKey == vitals.streamKey\r\n                # reconnecting, but rate matches so we can keep using\r\n                # our existing buffer.\r\n                @log.debug \"Rewind buffer validated new source.  Reusing buffer.\"\r\n\r\n            else\r\n                @_rChunkLength vitals\r\n\r\n            # connect our data listener\r\n            newsource.on \"data\", @_rdataFunc\r\n\r\n            # keep track of our source\r\n            @_rsource = newsource\r\n\r\n            cb? null\r\n\r\n    #----------\r\n\r\n    # Return rewind buffer status, including HTTP Live Streaming if enabled\r\n    _rStatus: ->\r\n        status =\r\n            buffer_length:      @_rbuffer.length()\r\n            first_buffer_ts:    @_rbuffer.first()?.ts\r\n            last_buffer_ts:     @_rbuffer.last()?.ts\r\n\r\n        if @hls_segmenter\r\n            _.extend status, @hls_segmenter.status()\r\n\r\n        status\r\n\r\n    #----------\r\n\r\n    _rChunkLength: (vitals) ->\r\n        if @_rstreamKey != vitals.streamKey\r\n            if @_rstreamKey\r\n                # we're reconnecting, but didn't match rate...  we\r\n                # should wipe out the old buffer\r\n                @log.debug \"Invalid existing rewind buffer. Reset.\"\r\n                @_rbuffer.reset()\r\n\r\n            # compute new frame numbers\r\n            @_rsecsPerChunk = vitals.emitDuration\r\n            @_rstreamKey    = vitals.streamKey\r\n\r\n            @_rUpdateMax()\r\n\r\n            @log.debug \"Rewind's max buffer length is \", max:@_rmax, secsPerChunk:@_rsecsPerChunk, secs:vitals.emitDuration\r\n\r\n    #----------\r\n\r\n    _rUpdateMax: ->\r\n        if @_rsecsPerChunk\r\n            @_rmax          = Math.round @_rsecs / @_rsecsPerChunk\r\n            @_rbuffer.setMax @_rmax\r\n            @_rburst        = Math.round @_rburstsecs / @_rsecsPerChunk\r\n        @log.debug \"Rewind's max buffer length is \", max:@_rmax, seconds:@_rsecs\r\n\r\n    #----------\r\n\r\n    getRewinder: (id,opts,cb) ->\r\n        # create a rewinder object\r\n        rewind = new Rewinder @, id, opts, cb\r\n\r\n        unless opts.pumpOnly\r\n            # add it to our list of listeners\r\n            @_raddListener rewind\r\n\r\n    #----------\r\n\r\n    recordListen: (opts) ->\r\n        # stub function. must be defined for real in the implementing class\r\n\r\n    #----------\r\n\r\n    bufferedSecs: ->\r\n        # convert buffer length to seconds\r\n        Math.round @_rbuffer.length() * @_rsecsPerChunk\r\n\r\n    #----------\r\n\r\n    # Insert a chunk into the RewindBuffer. Inserts can only go backward, so\r\n    # the timestamp must be less than @_rbuffer[0].ts for a valid chunk\r\n    _insertBuffer: (chunk) ->\r\n        @_rbuffer.insert chunk\r\n\r\n    #----------\r\n\r\n    # Load a RewindBuffer.  Buffer should arrive newest first, which means\r\n    # that we can simply shift() it into place and don't have to lock out\r\n    # any incoming data.\r\n\r\n    loadBuffer: (stream,cb) ->\r\n        @_risLoading = true\r\n        @emit \"rewind_loading\"\r\n\r\n        if !stream\r\n            # Calling loadBuffer with no stream is really just for testing\r\n            process.nextTick =>\r\n                @emit \"rewind_loaded\"\r\n                @_risLoading = false\r\n\r\n            @hls_segmenter._loadMap null if @hls_segmenter\r\n\r\n            return cb null, seconds:0, length:0\r\n\r\n        parser = Dissolve()\r\n            .uint32le(\"header_length\")\r\n            .tap ->\r\n                @buffer(\"header\",@vars.header_length)\r\n                    .tap ->\r\n                        @push JSON.parse(@vars.header)\r\n                        @vars = {}\r\n\r\n                        @loop (end) ->\r\n                            @uint8(\"meta_length\")\r\n                                .tap ->\r\n                                    @buffer(\"meta\",@vars.meta_length)\r\n                                        .uint16le(\"data_length\")\r\n                                        .tap ->\r\n                                            @buffer(\"data\",@vars.data_length)\r\n                                                .tap ->\r\n                                                    meta = JSON.parse @vars.meta.toString()\r\n                                                    @push ts:new Date(meta.ts), meta:meta.meta, duration:meta.duration, data:@vars.data\r\n                                                    @vars = {}\r\n\r\n        stream.pipe(parser)\r\n\r\n        headerRead = false\r\n\r\n        parser.on \"readable\", =>\r\n            while c = parser.read()\r\n                if !headerRead\r\n                    headerRead = true\r\n\r\n                    @emit \"header\", c\r\n                    @_rChunkLength emitDuration:c.secs_per_chunk, streamKey:c.stream_key\r\n\r\n                    if c.hls && @hls_segmenter\r\n                        @hls_segmenter._loadMap c.hls\r\n\r\n                else\r\n                    @_insertBuffer(c)\r\n                    @emit \"buffer\", c\r\n\r\n                true\r\n\r\n        parser.on \"end\", =>\r\n            obj = seconds:@bufferedSecs(), length:@_rbuffer.length()\r\n            @log.info \"RewindBuffer is now at \", obj\r\n            @emit \"rewind_loaded\"\r\n            @_risLoading = false\r\n            cb? null, obj\r\n\r\n    #----------\r\n\r\n    # Dump the rewindbuffer. We want to dump the newest data first, so that\r\n    # means running back from the end of the array to the front.\r\n\r\n    dumpBuffer: (cb) ->\r\n        # taking a copy of the array should effectively freeze us in place\r\n        @_rbuffer.clone (err,rbuf_copy) =>\r\n            if err\r\n                cb err\r\n                return false\r\n\r\n            go = (hls) =>\r\n                writer = new RewindBuffer.RewindWriter rbuf_copy, @_rsecsPerChunk, @_rstreamKey, hls\r\n                cb null, writer\r\n\r\n            if @hls_segmenter\r\n                @hls_segmenter._dumpMap (err,info) =>\r\n                    return cb err if err\r\n                    go info\r\n\r\n            else\r\n                go()\r\n\r\n\r\n    #----------\r\n\r\n    checkOffsetSecs: (secs) ->\r\n        @checkOffset @secsToOffset(secs)\r\n\r\n    #----------\r\n\r\n    checkOffset: (offset) ->\r\n        bl = @_rbuffer.length()\r\n\r\n        if offset < 0\r\n            @log.silly \"offset is invalid! 0 for live.\"\r\n            return 0\r\n\r\n        if bl >= offset\r\n            @log.silly \"Granted. current buffer length is \", length:bl\r\n            return offset\r\n        else\r\n            @log.silly \"Not available. Instead giving max buffer of \", length:bl - 1\r\n            return bl - 1\r\n\r\n    #----------\r\n\r\n    secsToOffset: (secs) ->\r\n        Math.round Number(secs) / @_rsecsPerChunk\r\n\r\n    #----------\r\n\r\n    offsetToSecs: (offset) ->\r\n        Math.round Number(offset) * @_rsecsPerChunk\r\n\r\n    #----------\r\n\r\n    timestampToOffset: (time,cb) ->\r\n        cb null, @_rbuffer._findTimestampOffset time\r\n\r\n    #----------\r\n\r\n    pumpSeconds: (rewinder,seconds,concat,cb) ->\r\n        # pump the most recent X seconds\r\n        frames = @checkOffsetSecs seconds\r\n        @pumpFrom rewinder, frames, frames, concat, cb\r\n\r\n    #----------\r\n\r\n    pumpFrom: (rewinder,offset,length,concat,cb) ->\r\n        # we want to send _length_ chunks, starting at _offset_\r\n\r\n        if offset == 0 || length == 0\r\n            cb? null, null\r\n            return true\r\n\r\n        @_rbuffer.range offset, length, (err,chunks) =>\r\n            pumpLen     = 0\r\n            duration    = 0\r\n            meta        = null\r\n            buffers     = []\r\n\r\n            for b in chunks\r\n                pumpLen     += b.data.length\r\n                duration    += b.duration\r\n\r\n                if concat\r\n                  buffers.push b.data\r\n                else\r\n                  rewinder._insert b\r\n\r\n                meta = b.meta if !meta\r\n\r\n            if concat\r\n                cbuf = Buffer.concat(buffers)\r\n                rewinder._insert { data:cbuf, meta:meta, duration:duration }\r\n\r\n            offsetSeconds = if (offset instanceof Date)\r\n                # how many seconds are between this date and the end of the\r\n                # buffer?\r\n                ( Number(@_rbuffer.last().ts) - Number(offset) ) / 1000\r\n            else\r\n                @offsetToSecs(offset)\r\n\r\n            @log?.silly \"Converting offset to seconds: \", offset:offset, secs:offsetSeconds\r\n            cb? null, meta:meta, duration:duration, length:pumpLen, offsetSeconds:offsetSeconds\r\n\r\n    #----------\r\n\r\n    burstFrom: (rewinder,offset,burstSecs,cb) ->\r\n        # we want to send them @burst frames (if available), starting at offset.\r\n        # return them the new offset position and the burst data\r\n\r\n        # convert burstSecs to frames\r\n        burst = @checkOffsetSecs burstSecs\r\n\r\n        if offset > burst\r\n            @pumpFrom rewinder, offset, burst, false, (err,info) =>\r\n                cb? err, offset-burst\r\n        else\r\n            @pumpFrom rewinder, offset, offset, false, (err,info) =>\r\n                cb? err, 0\r\n\r\n    #----------\r\n\r\n    _raddListener: (obj) ->\r\n        if obj._offset? && obj._offset >= 0\r\n            @_rlisteners.push obj\r\n            return true\r\n        else\r\n            return false\r\n\r\n    #----------\r\n\r\n    _rremoveListener: (obj) ->\r\n        @_rlisteners = _(@_rlisteners).without obj\r\n        return true\r\n\r\n    #----------\r\n\r\n    class @RewindWriter extends require(\"stream\").Readable\r\n        constructor: (@buf,@secs,@streamKey,@hls) ->\r\n            super()\r\n\r\n            @c          = Concentrate()\r\n            @slices     = 0\r\n            @i          = @buf.length - 1\r\n            @_ended     = false\r\n\r\n            super highWaterMark:25*1024*1024\r\n\r\n            # make sure there's something to send\r\n            if @buf.length == 0\r\n                @push null\r\n                return false\r\n\r\n            @_writeHeader()\r\n\r\n        #----------\r\n\r\n        _writeHeader: (cb) ->\r\n            # -- Write header -- #\r\n\r\n            header_buf = Buffer.from JSON.stringify\r\n                start_ts:       @buf[0].ts\r\n                end_ts:         @buf[ @buf.length - 1 ].ts\r\n                secs_per_chunk: @secs\r\n                stream_key:     @streamKey\r\n                hls:            @hls\r\n\r\n            # header buffer length\r\n            @c.uint32le header_buf.length\r\n\r\n            # header buffer json\r\n            @c.buffer header_buf\r\n\r\n            @push @c.result()\r\n            @c.reset()\r\n\r\n        #----------\r\n\r\n        _read: (size) ->\r\n            if @i < 0\r\n                return false\r\n\r\n            # -- Data Chunks -- #\r\n            wlen = 0\r\n\r\n            loop\r\n                chunk = @buf[ @i ]\r\n\r\n                meta_buf = Buffer.from JSON.stringify ts:chunk.ts, meta:chunk.meta, duration:chunk.duration\r\n\r\n                # 1) metadata length\r\n                @c.uint8 meta_buf.length\r\n\r\n                # 2) metadata json\r\n                @c.buffer meta_buf\r\n\r\n                # 3) data chunk length\r\n                @c.uint16le chunk.data.length\r\n\r\n                # 4) data chunk\r\n                @c.buffer chunk.data\r\n\r\n                r = @c.result()\r\n                @c.reset()\r\n                result = @push r\r\n\r\n                wlen += r.length\r\n\r\n                @i -= 1\r\n\r\n                if @i < 0\r\n                    # finished\r\n                    @push null\r\n                    return true\r\n\r\n                if !result || wlen > size\r\n                    return false\r\n\r\n                # otherwise loop again\r\n"
  ]
}